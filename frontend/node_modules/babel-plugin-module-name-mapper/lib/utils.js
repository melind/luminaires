"use strict";

exports.__esModule = true;
exports.traverseExpression = exports.lazyFindPkgDir = void 0;

var _lodash = _interopRequireDefault(require("lodash.memoize"));

var _path = require("path");

var _fs = require("fs");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// @docs https://github.com/shinnn/find-pkg-dir/blob/master/index.js
// const PKG_ERROR = new Error('package.json not found');
const PKG_FILENAME = 'package.json';
const lazyFindPkgDir = (0, _lodash.default)(dirName => {
  const actualDirName = (0, _path.resolve)(dirName);

  const _parse = (0, _path.parse)(actualDirName),
        root = _parse.root;

  const pkgPath = (0, _path.join)(actualDirName, PKG_FILENAME);
  const pkgExists = (0, _fs.existsSync)(pkgPath);

  if (pkgExists) {
    return (0, _path.dirname)(pkgPath);
  }

  if (dirName === root) {
    return null;
  }

  return lazyFindPkgDir((0, _path.dirname)(dirName));
  /*
  try {
    const pkgPath = require.resolve(join(actualDirName, PKG_FILENAME))
    if (basename(pkgPath) !== PKG_FILENAME) {
      throw PKG_ERROR;
    }
    return dirname(pkgPath);
  } catch (err) {
    if (dirName === root) {
      return null;
    }
    return lazyFindPkgDir(dirname(dirName));
  }
  */
});
/**
 * Recursively traverses binary  expressions to find the first `StringLiteral` if any.
 * @param  {Object} t           Babel types
 * @param  {Node} arg           a Babel node
 * @return {StringLiteral?}
 */

exports.lazyFindPkgDir = lazyFindPkgDir;

const traverseExpression = (t, arg) => {
  if (t.isStringLiteral(arg)) {
    return arg;
  }

  if (t.isBinaryExpression(arg)) {
    return traverseExpression(t, arg.left);
  }

  return null;
};

exports.traverseExpression = traverseExpression;
//# sourceMappingURL=utils.js.map