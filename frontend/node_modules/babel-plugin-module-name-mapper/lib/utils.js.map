{"version":3,"sources":["../src/utils.js"],"names":["PKG_FILENAME","lazyFindPkgDir","dirName","actualDirName","root","pkgPath","pkgExists","traverseExpression","t","arg","isStringLiteral","isBinaryExpression","left"],"mappings":";;;;;AAEA;;AACA;;AACA;;;;AAJA;AAMA;AACA,MAAMA,YAAY,GAAG,cAArB;AACO,MAAMC,cAAc,GAAG,qBAAQC,OAAO,IAAI;AAC/C,QAAMC,aAAa,GAAG,mBAAQD,OAAR,CAAtB;;AAD+C,iBAEhC,iBAAMC,aAAN,CAFgC;AAAA,QAExCC,IAFwC,UAExCA,IAFwC;;AAI/C,QAAMC,OAAO,GAAG,gBAAKF,aAAL,EAAoBH,YAApB,CAAhB;AACA,QAAMM,SAAS,GAAG,oBAAWD,OAAX,CAAlB;;AACA,MAAIC,SAAJ,EAAe;AACb,WAAO,mBAAQD,OAAR,CAAP;AACD;;AACD,MAAIH,OAAO,KAAKE,IAAhB,EAAsB;AACpB,WAAO,IAAP;AACD;;AACD,SAAOH,cAAc,CAAC,mBAAQC,OAAR,CAAD,CAArB;AACA;;;;;;;;;;;;;;AAcD,CA3B6B,CAAvB;AA6BP;;;;;;;;;AAMO,MAAMK,kBAAkB,GAAG,CAACC,CAAD,EAAIC,GAAJ,KAAY;AAC5C,MAAID,CAAC,CAACE,eAAF,CAAkBD,GAAlB,CAAJ,EAA4B;AAC1B,WAAOA,GAAP;AACD;;AACD,MAAID,CAAC,CAACG,kBAAF,CAAqBF,GAArB,CAAJ,EAA+B;AAC7B,WAAOF,kBAAkB,CAACC,CAAD,EAAIC,GAAG,CAACG,IAAR,CAAzB;AACD;;AACD,SAAO,IAAP;AACD,CARM","sourcesContent":["// @docs https://github.com/shinnn/find-pkg-dir/blob/master/index.js\n\nimport memoize from 'lodash.memoize';\nimport {/* basename, */ dirname, join, parse, resolve} from 'path';\nimport {existsSync} from 'fs';\n\n// const PKG_ERROR = new Error('package.json not found');\nconst PKG_FILENAME = 'package.json';\nexport const lazyFindPkgDir = memoize(dirName => {\n  const actualDirName = resolve(dirName);\n  const {root} = parse(actualDirName);\n\n  const pkgPath = join(actualDirName, PKG_FILENAME);\n  const pkgExists = existsSync(pkgPath);\n  if (pkgExists) {\n    return dirname(pkgPath);\n  }\n  if (dirName === root) {\n    return null;\n  }\n  return lazyFindPkgDir(dirname(dirName));\n  /*\n  try {\n    const pkgPath = require.resolve(join(actualDirName, PKG_FILENAME))\n    if (basename(pkgPath) !== PKG_FILENAME) {\n      throw PKG_ERROR;\n    }\n    return dirname(pkgPath);\n  } catch (err) {\n    if (dirName === root) {\n      return null;\n    }\n    return lazyFindPkgDir(dirname(dirName));\n  }\n  */\n});\n\n/**\n * Recursively traverses binary  expressions to find the first `StringLiteral` if any.\n * @param  {Object} t           Babel types\n * @param  {Node} arg           a Babel node\n * @return {StringLiteral?}\n */\nexport const traverseExpression = (t, arg) => {\n  if (t.isStringLiteral(arg)) {\n    return arg;\n  }\n  if (t.isBinaryExpression(arg)) {\n    return traverseExpression(t, arg.left);\n  }\n  return null;\n};\n"],"file":"utils.js"}